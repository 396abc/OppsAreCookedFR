<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sigma Breathing Aura</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #000000;
      --secondary-color: #333333;
      --accent-color: #00ffcc;
      --text-color: #333333;
      --light-text: #666666;
      --glass-bg: rgba(255, 255, 255, 0.15);
      --glass-border: rgba(255, 255, 255, 0.2);
      --grid-color: rgba(0, 0, 0, 0.05);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: #ffffff;
      color: var(--text-color);
      font-family: "Poppins", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
      text-align: center;
      position: relative;
    }

    /* Grid Background */
    .grid-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(var(--grid-color) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
      background-size: 50px 50px;
      z-index: -1;
      opacity: 0.5;
    }

    /* Floating Particles */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      background-color: rgba(100, 100, 100, 0.15);
      opacity: 0.4;
      transition: transform 2s ease-in-out;
    }

    /* Glass Morphism Elements */
    .glass-container {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      margin: 20px;
      width: 90%;
      max-width: 500px;
      z-index: 10;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 20px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    #circle-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 0 auto 30px;
    }

    #circle {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: var(--primary-color);
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.2);
      transition: transform 2s ease-in-out;
      position: relative;
      overflow: hidden;
    }

    #circle::before {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.1) 0%, transparent 70%);
      border-radius: 50%;
      z-index: -1;
      animation: pulse 4s ease-in-out infinite;
    }

    #inner-circle {
      position: absolute;
      width: 80%;
      height: 80%;
      border-radius: 50%;
      top: 10%;
      left: 10%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
    }

    #caption {
      font-size: 1.8rem;
      font-weight: 600;
      margin-bottom: 15px;
      transition: all 0.5s ease;
    }

    #quote-container {
      height: 80px;
      margin: 20px 0;
      position: relative;
      overflow: hidden;
    }

    #quote {
      font-size: 1.1rem;
      color: var(--light-text);
      font-style: italic;
      position: absolute;
      width: 100%;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.8s ease;
    }

    #quote.active {
      opacity: 1;
      transform: translateY(0);
    }

    #quote.fade-out {
      opacity: 0;
      transform: translateY(-20px);
    }

    #timer {
      font-size: 1.2rem;
      font-weight: 500;
      margin: 15px 0;
      color: var(--light-text);
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
    }

    button {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      color: var(--text-color);
      padding: 12px 25px;
      border-radius: 50px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
      font-family: "Poppins", sans-serif;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
    }

    button:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    }

    button:active {
      transform: translateY(0);
    }

    #main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    #main-menu.active {
      opacity: 1;
      pointer-events: all;
    }

    .menu-content {
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.1);
      max-width: 600px;
      width: 90%;
    }

    .menu-title {
      font-size: 2rem;
      margin-bottom: 30px;
      color: var(--primary-color);
    }

    .exercise-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .exercise-card {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .exercise-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }

    .exercise-card h3 {
      margin-bottom: 10px;
      color: var(--primary-color);
    }

    .exercise-card p {
      color: var(--light-text);
      font-size: 0.9rem;
    }

    .close-menu {
      position: absolute;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-color);
    }

    .stats {
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
      font-size: 0.9rem;
      color: var(--light-text);
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .stat-value {
      font-weight: 600;
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    /* Emotional Interruption Styles */
    .emotional-interruption {
      position: fixed;
      z-index: 50;
      opacity: 0;
      transition: all 0.8s ease;
      font-size: 1.4rem;
      font-weight: 600;
      color: #ff4757;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      pointer-events: none;
    }

    .emotional-interruption.active {
      opacity: 1;
    }

    .emotional-interruption.fade-out {
      opacity: 0;
    }

    .cross-line {
      position: absolute;
      top: 50%;
      left: 0;
      width: 0;
      height: 3px;
      background-color: #ff4757;
      transform: translateY(-50%);
      transition: width 0.8s ease;
      z-index: 2;
    }

    .emotional-interruption.crossed .cross-line {
      width: 100%;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 0.7;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.4;
      }
      100% {
        transform: scale(1);
        opacity: 0.7;
      }
    }

    @keyframes glow {
      0% {
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
      }
      50% {
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
      }
      100% {
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
      }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      .glass-container {
        padding: 20px;
      }
      
      #circle-container {
        width: 150px;
        height: 150px;
      }
      
      .exercise-grid {
        grid-template-columns: 1fr;
      }
      
      .emotional-interruption {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <div class="grid-bg"></div>
  <div class="particles" id="particles"></div>

  <div class="glass-container">
    <h1>Sigma Breathing Aura üå¨Ô∏è</h1>
    
    <div id="circle-container">
      <div id="circle">
        <div id="inner-circle"></div>
      </div>
    </div>
    
    <div id="caption">Press Start</div>
    
    <div id="quote-container">
      <div id="quote"></div>
    </div>
    
    <div id="timer">02:00</div>
    
    <div class="stats">
      <div class="stat-item">
        <span class="stat-label">Sessions</span>
        <span class="stat-value" id="session-count">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Focus Time</span>
        <span class="stat-value" id="focus-time">0m</span>
      </div>
    </div>
    
    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="menuBtn">Exercises</button>
    </div>
  </div>

  <div id="main-menu">
    <button class="close-menu">‚úï</button>
    <div class="menu-content">
      <h2 class="menu-title">Breathing Exercises</h2>
      <div class="exercise-grid">
        <div class="exercise-card" data-exercise="box">
          <h3>Box Breathing</h3>
          <p>4-second inhale, hold, exhale, hold</p>
        </div>
        <div class="exercise-card" data-exercise="478">
          <h3>4-7-8 Breathing</h3>
          <p>Inhale 4s, hold 7s, exhale 8s</p>
        </div>
        <div class="exercise-card" data-exercise="alternate">
          <h3>Alternate Nostril</h3>
          <p>Balancing breath through nostrils</p>
        </div>
        <div class="exercise-card" data-exercise="coherent">
          <h3>Coherent Breathing</h3>
          <p>5-second inhale and exhale</p>
        </div>
        <div class="exercise-card" data-exercise="sigma">
          <h3>Sigma Pattern</h3>
          <p>2-second inhale, 4-second exhale</p>
        </div>
        <div class="exercise-card" data-exercise="custom">
          <h3>Custom Pattern</h3>
          <p>Create your own breathing rhythm</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const circle = document.getElementById("circle");
    const caption = document.getElementById("caption");
    const timerDisplay = document.getElementById("timer");
    const quoteBox = document.getElementById("quote");
    const startBtn = document.getElementById("startBtn");
    const menuBtn = document.getElementById("menuBtn");
    const mainMenu = document.getElementById("main-menu");
    const closeMenu = document.querySelector(".close-menu");
    const exerciseCards = document.querySelectorAll(".exercise-card");
    const sessionCount = document.getElementById("session-count");
    const focusTime = document.getElementById("focus-time");
    const particlesContainer = document.getElementById("particles");

    // Breathing quotes
    const sigmaQuotes = [
      "Keep aura farming and you'll mog every opp out there.",
      "Inhale the rizz, exhale the doubt.",
      "Stay calm, stay sigma, stay skibidi.",
      "Bro, your focus is your final boss. Cook it.",
      "Real sigmas breathe silence, not stress.",
      "Keep your gyat centered and your aura glowing.",
      "The grind breathes with you ‚Äî keep inhaling greatness.",
      "No fear. No diddy. Only rizz and peace.",
      "When you exhale, you delete every opp in your mind.",
      "Aura's leveling up... stay locked in, rizzler."
    ];

    // Emotional interruptions data
    const emotionalInterruptions = [
      "Stress",
      "Anxiety",
      "The Urge to Goon",
      "Distraction",
      "Restlessness",
      "Overthinking",
      "Impatience",
      "Self-Doubt"
    ];

    // Variables
    let breathingInterval, countdownInterval, quoteInterval, emotionInterval;
    let totalTime = 120; // 2 minutes
    let breathingPhase = "inhale";
    let startTime;
    let paused = false;
    let sessionsCompleted = 0;
    let totalFocusTime = 0;
    let currentQuoteIndex = 0;
    let currentEmotionIndex = 0;
    let particles = [];
    let circleCenter = { x: 0, y: 0 };
    let particleAnimationId = null;

    // Calculate circle center position
    function updateCircleCenter() {
      const circleRect = document.getElementById('circle-container').getBoundingClientRect();
      circleCenter.x = circleRect.left + circleRect.width / 2;
      circleCenter.y = circleRect.top + circleRect.height / 2;
    }

    // Initialize particles
    function createParticles() {
      const particleCount = 30;
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement("div");
        particle.classList.add("particle");
        
        // Random size (larger particles)
        const baseSize = Math.random() * 12 + 8; // 8-20px
        particle.style.width = `${baseSize}px`;
        particle.style.height = `${baseSize}px`;
        
        // Random position (avoiding the center breathing area)
        const position = getRandomPosition();
        
        particle.style.left = `${position.x}%`;
        particle.style.top = `${position.y}%`;
        
        // Store particle data for animation
        const particleData = {
          element: particle,
          baseSize: baseSize,
          currentSize: baseSize,
          x: position.x,
          y: position.y,
          baseX: position.x,
          baseY: position.y,
          speed: Math.random() * 0.8 + 0.4, // Balanced speed: 0.4-1.2
          pulseSpeed: Math.random() * 0.02 + 0.01, // 0.01-0.03
          pulsePhase: Math.random() * Math.PI * 2,
          moveDistance: Math.random() * 40 + 30, // 30-70px movement toward circle
          isMoving: false,
          targetX: position.x,
          targetY: position.y,
          progress: 0
        };
        
        particles.push(particleData);
        particlesContainer.appendChild(particle);
        
        // Start pulsing animation
        pulseParticle(particleData);
      }
    }

    // Check if position is over the circle area
    function isPositionOverCircle(xPercent, yPercent) {
      const circleRect = document.getElementById('circle-container').getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      const xPos = (xPercent / 100) * viewportWidth;
      const yPos = (yPercent / 100) * viewportHeight;
      
      const circleRadius = circleRect.width / 2;
      const distance = Math.sqrt(
        Math.pow(xPos - circleCenter.x, 2) + 
        Math.pow(yPos - circleCenter.y, 2)
      );
      
      // Return true if position is within 1.5x the circle radius
      return distance < circleRadius * 1.5;
    }

    // Animate particle pulsing
    function pulseParticle(particle) {
      const pulse = () => {
        const scale = 1 + Math.sin(particle.pulsePhase) * 0.3; // 0.7-1.3 scale
        particle.currentSize = particle.baseSize * scale;
        particle.element.style.width = `${particle.currentSize}px`;
        particle.element.style.height = `${particle.currentSize}px`;
        particle.pulsePhase += particle.pulseSpeed;
        requestAnimationFrame(pulse);
      };
      pulse();
    }

    // Get random position that doesn't overlap with circle
    function getRandomPosition() {
      let x, y;
      const maxAttempts = 50;
      let attempts = 0;
      
      do {
        x = Math.random() * 80 + 10; // 10-90%
        y = Math.random() * 80 + 10; // 10-90%
        attempts++;
      } while (isPositionOverCircle(x, y) && attempts < maxAttempts);
      
      return { x, y };
    }

    // Move particles toward/away from circle based on breathing
    function updateParticlePositions() {
      const isInhaling = breathingPhase === "inhale" && !paused;
      
      particles.forEach(particle => {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        const particleX = (particle.x / 100) * viewportWidth;
        const particleY = (particle.y / 100) * viewportHeight;
        
        // Calculate direction vector toward circle center
        const dx = circleCenter.x - particleX;
        const dy = circleCenter.y - particleY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Normalize direction
        const dirX = dx / distance;
        const dirY = dy / distance;
        
        if (isInhaling) {
          // Move toward circle during inhale - full movement
          const baseX = (particle.baseX / 100) * viewportWidth;
          const baseY = (particle.baseY / 100) * viewportHeight;
          
          // Calculate maximum movement toward circle (stop at circle edge + margin)
          const maxMoveDistance = distance - 60; // Stop 60px from circle center
          
          if (maxMoveDistance > 0) {
            // Increase progress during inhalation
            particle.progress = Math.min(particle.progress + particle.speed * 0.02, 1);
            
            // Calculate target position using easing
            const easedProgress = easeInOutCubic(particle.progress);
            const moveDistance = maxMoveDistance * easedProgress;
            
            particle.targetX = baseX + dirX * moveDistance;
            particle.targetY = baseY + dirY * moveDistance;
          }
        } else {
          // Return to base position during exhale
          const baseX = (particle.baseX / 100) * viewportWidth;
          const baseY = (particle.baseY / 100) * viewportHeight;
          
          // Decrease progress during exhalation
          particle.progress = Math.max(particle.progress - particle.speed * 0.02, 0);
          
          // Calculate target position using easing
          const easedProgress = easeInOutCubic(particle.progress);
          const currentDistance = Math.sqrt(
            Math.pow(baseX - particleX, 2) + 
            Math.pow(baseY - particleY, 2)
          );
          
          const moveDistance = currentDistance * (1 - easedProgress);
          const dirToBaseX = (baseX - particleX) / currentDistance;
          const dirToBaseY = (baseY - particleY) / currentDistance;
          
          particle.targetX = particleX + dirToBaseX * moveDistance;
          particle.targetY = particleY + dirToBaseY * moveDistance;
        }
        
        // Smoothly interpolate toward target position
        const dxToTarget = particle.targetX - particleX;
        const dyToTarget = particle.targetY - particleY;
        
        // Move directly to target with the particle's speed
        const moveStep = particle.speed;
        const moveX = particleX + dxToTarget * 0.1;
        const moveY = particleY + dyToTarget * 0.1;
        
        // Convert back to percentages and update
        particle.x = (moveX / viewportWidth) * 100;
        particle.y = (moveY / viewportHeight) * 100;
        
        particle.element.style.left = `${particle.x}%`;
        particle.element.style.top = `${particle.y}%`;
      });
      
      // Continue animation if breathing is active
      if (startTime && !paused) {
        particleAnimationId = requestAnimationFrame(updateParticlePositions);
      }
    }

    // Easing function for smooth movement
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // Show emotional interruption
    function showEmotionalInterruption() {
      if (paused) return;
      
      const emotion = emotionalInterruptions[currentEmotionIndex];
      const emotionElement = document.createElement("div");
      emotionElement.classList.add("emotional-interruption");
      emotionElement.innerHTML = `
        <div class="emotion-text">${emotion}</div>
        <div class="cross-line"></div>
      `;
      
      // Get random position
      const position = getRandomPosition();
      emotionElement.style.left = `${position.x}%`;
      emotionElement.style.top = `${position.y}%`;
      
      document.body.appendChild(emotionElement);
      
      // Show the interruption
      setTimeout(() => {
        emotionElement.classList.add("active");
        
        // Cross it out after a short delay
        setTimeout(() => {
          emotionElement.classList.add("crossed");
          
          // Fade out after being crossed
          setTimeout(() => {
            emotionElement.classList.remove("active", "crossed");
            emotionElement.classList.add("fade-out");
            
            // Remove from DOM after fade out
            setTimeout(() => {
              if (emotionElement.parentNode) {
                emotionElement.parentNode.removeChild(emotionElement);
              }
            }, 800);
          }, 1500);
        }, 800);
      }, 100);
      
      // Update emotion index for next time
      currentEmotionIndex = (currentEmotionIndex + 1) % emotionalInterruptions.length;
    }

    // Update timer display
    function updateTimer() {
      if (paused) return;
      const remaining = totalTime - Math.floor((Date.now() - startTime) / 1000);
      if (remaining >= 0) {
        const minutes = String(Math.floor(remaining / 60)).padStart(2, "0");
        const seconds = String(remaining % 60).padStart(2, "0");
        timerDisplay.textContent = `${minutes}:${seconds}`;
      } else {
        stopBreathing();
        sessionsCompleted++;
        totalFocusTime += 2; // 2 minutes per session
        sessionCount.textContent = sessionsCompleted;
        focusTime.textContent = `${totalFocusTime}m`;
        holdBreath();
      }
    }

    // Stop all breathing intervals
    function stopBreathing() {
      clearInterval(breathingInterval);
      clearInterval(countdownInterval);
      clearInterval(quoteInterval);
      clearInterval(emotionInterval);
      if (particleAnimationId) {
        cancelAnimationFrame(particleAnimationId);
        particleAnimationId = null;
      }
    }

    // Start breathing exercise
    function startBreathing() {
      totalTime = 120;
      startTime = Date.now();
      paused = false;
      caption.textContent = "Inhale...";
      // Reduced circle scaling
      circle.style.transform = "scale(1.2)";
      breathingPhase = "inhale";
      
      // Update circle center position
      updateCircleCenter();
      
      // Add glow effect during breathing
      circle.style.animation = "glow 2s ease-in-out infinite";

      breathingInterval = setInterval(() => {
        if (paused) return;
        if (breathingPhase === "inhale") {
          breathingPhase = "exhale";
          caption.textContent = "Exhale...";
          // Reduced circle scaling
          circle.style.transform = "scale(0.9)";
        } else {
          breathingPhase = "inhale";
          caption.textContent = "Inhale...";
          // Reduced circle scaling
          circle.style.transform = "scale(1.2)";
        }
      }, 6000); // 2s inhale + 4s exhale = 6s per cycle

      countdownInterval = setInterval(updateTimer, 1000);
      
      // Start particle movement animation
      if (!particleAnimationId) {
        particleAnimationId = requestAnimationFrame(updateParticlePositions);
      }
      
      // Show first quote immediately
      showNextQuote();
      
      // Then show quotes every 8 seconds
      quoteInterval = setInterval(() => {
        if (!paused) {
          showNextQuote();
        }
      }, 8000);
      
      // Show emotional interruptions every 20 seconds
      emotionInterval = setInterval(() => {
        if (!paused) {
          showEmotionalInterruption();
        }
      }, 20000);
    }

    // Show next quote with animation
    function showNextQuote() {
      // Fade out current quote
      quoteBox.classList.add("fade-out");
      
      setTimeout(() => {
        // Update quote text
        quoteBox.textContent = `"${sigmaQuotes[currentQuoteIndex]}"`;
        currentQuoteIndex = (currentQuoteIndex + 1) % sigmaQuotes.length;
        
        // Remove fade-out class and add active class
        quoteBox.classList.remove("fade-out");
        quoteBox.classList.add("active");
      }, 400);
    }

    // Hold breath at the end
    function holdBreath() {
      caption.textContent = "Hold your breath...";
      circle.style.transform = "scale(1.05)";
      circle.style.animation = "pulse 2s ease-in-out infinite";
      
      let holdTime = 20;
      const holdInterval = setInterval(() => {
        timerDisplay.textContent = `Hold: ${holdTime}s`;
        holdTime--;
        if (holdTime < 0) {
          clearInterval(holdInterval);
          caption.textContent = "Done ‚úÖ";
          timerDisplay.textContent = "Session Complete";
          quoteBox.textContent = "You cooked it, sigma.";
          circle.style.animation = "none";
        }
      }, 1000);
    }

    // Toggle pause/resume
    function togglePause() {
      if (!startTime) return;
      paused = !paused;
      if (paused) {
        caption.textContent = "Paused ‚Äî take a breather, king üëë";
        circle.style.animation = "pulse 3s ease-in-out infinite";
        if (particleAnimationId) {
          cancelAnimationFrame(particleAnimationId);
          particleAnimationId = null;
        }
      } else {
        caption.textContent = breathingPhase === "inhale" ? "Inhale..." : "Exhale...";
        circle.style.animation = "glow 2s ease-in-out infinite";
        if (!particleAnimationId) {
          particleAnimationId = requestAnimationFrame(updateParticlePositions);
        }
      }
    }

    // Toggle main menu
    function toggleMenu() {
      mainMenu.classList.toggle("active");
    }

    // Event Listeners
    startBtn.addEventListener("click", () => {
      startBreathing();
    });

    menuBtn.addEventListener("click", toggleMenu);
    
    closeMenu.addEventListener("click", toggleMenu);

    document.body.addEventListener("click", (e) => {
      if (e.target.tagName !== "BUTTON" && e.target.id !== "menuBtn") {
        togglePause();
      }
    });

    // Exercise card selection
    exerciseCards.forEach(card => {
      card.addEventListener("click", () => {
        const exercise = card.getAttribute("data-exercise");
        alert(`Starting ${exercise} breathing exercise`);
        toggleMenu();
        // Here you would implement the specific breathing pattern
        startBreathing();
      });
    });

    // Update circle center on resize
    window.addEventListener('resize', updateCircleCenter);

    // Initialize the page
    function init() {
      updateCircleCenter();
      createParticles();
      // Add idle pulse animation to circle
      circle.style.animation = "pulse 4s ease-in-out infinite";
    }

    // Start initialization when page loads
    window.addEventListener("load", init);
  </script>
</body>
</html>
